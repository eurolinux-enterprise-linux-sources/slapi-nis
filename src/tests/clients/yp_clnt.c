/*
 * Please do not edit this file.
 * It was generated using rpcgen.
 */

#include <memory.h> /* for memset */
#include "../../yp/yp.h"

/* Default timeout can be changed using clnt_control() */
static struct timeval TIMEOUT = { 25, 0 };

void *
ypproc_null_2(void *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPROC_NULL,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

bool_t *
ypproc_domain_2(domainname *argp, CLIENT *clnt)
{
	static bool_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPROC_DOMAIN,
		(xdrproc_t) xdr_domainname, (caddr_t) argp,
		(xdrproc_t) xdr_bool, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

bool_t *
ypproc_domain_nonack_2(domainname *argp, CLIENT *clnt)
{
	static bool_t clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPROC_DOMAIN_NONACK,
		(xdrproc_t) xdr_domainname, (caddr_t) argp,
		(xdrproc_t) xdr_bool, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

ypresp_val *
ypproc_match_2(ypreq_key *argp, CLIENT *clnt)
{
	static ypresp_val clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPROC_MATCH,
		(xdrproc_t) xdr_ypreq_key, (caddr_t) argp,
		(xdrproc_t) xdr_ypresp_val, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

ypresp_key_val *
ypproc_first_2(ypreq_key *argp, CLIENT *clnt)
{
	static ypresp_key_val clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPROC_FIRST,
		(xdrproc_t) xdr_ypreq_key, (caddr_t) argp,
		(xdrproc_t) xdr_ypresp_key_val, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

ypresp_key_val *
ypproc_next_2(ypreq_key *argp, CLIENT *clnt)
{
	static ypresp_key_val clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPROC_NEXT,
		(xdrproc_t) xdr_ypreq_key, (caddr_t) argp,
		(xdrproc_t) xdr_ypresp_key_val, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

ypresp_xfr *
ypproc_xfr_2(ypreq_xfr *argp, CLIENT *clnt)
{
	static ypresp_xfr clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPROC_XFR,
		(xdrproc_t) xdr_ypreq_xfr, (caddr_t) argp,
		(xdrproc_t) xdr_ypresp_xfr, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

void *
ypproc_clear_2(void *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPROC_CLEAR,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

ypresp_all *
ypproc_all_2(ypreq_nokey *argp, CLIENT *clnt)
{
	static ypresp_all clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPROC_ALL,
		(xdrproc_t) xdr_ypreq_nokey, (caddr_t) argp,
		(xdrproc_t) xdr_ypresp_all, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

ypresp_master *
ypproc_master_2(ypreq_nokey *argp, CLIENT *clnt)
{
	static ypresp_master clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPROC_MASTER,
		(xdrproc_t) xdr_ypreq_nokey, (caddr_t) argp,
		(xdrproc_t) xdr_ypresp_master, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

ypresp_order *
ypproc_order_2(ypreq_nokey *argp, CLIENT *clnt)
{
	static ypresp_order clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPROC_ORDER,
		(xdrproc_t) xdr_ypreq_nokey, (caddr_t) argp,
		(xdrproc_t) xdr_ypresp_order, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

ypresp_maplist *
ypproc_maplist_2(domainname *argp, CLIENT *clnt)
{
	static ypresp_maplist clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPROC_MAPLIST,
		(xdrproc_t) xdr_domainname, (caddr_t) argp,
		(xdrproc_t) xdr_ypresp_maplist, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

void *
yppushproc_null_1(void *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPUSHPROC_NULL,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

void *
yppushproc_xfrresp_1(yppushresp_xfr *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPPUSHPROC_XFRRESP,
		(xdrproc_t) xdr_yppushresp_xfr, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

void *
ypbindproc_null_2(void *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPBINDPROC_NULL,
		(xdrproc_t) xdr_void, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}

ypbind_resp *
ypbindproc_domain_2(domainname *argp, CLIENT *clnt)
{
	static ypbind_resp clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPBINDPROC_DOMAIN,
		(xdrproc_t) xdr_domainname, (caddr_t) argp,
		(xdrproc_t) xdr_ypbind_resp, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return (&clnt_res);
}

void *
ypbindproc_setdom_2(ypbind_setdom *argp, CLIENT *clnt)
{
	static char clnt_res;

	memset((char *)&clnt_res, 0, sizeof(clnt_res));
	if (clnt_call (clnt, YPBINDPROC_SETDOM,
		(xdrproc_t) xdr_ypbind_setdom, (caddr_t) argp,
		(xdrproc_t) xdr_void, (caddr_t) &clnt_res,
		TIMEOUT) != RPC_SUCCESS) {
		return (NULL);
	}
	return ((void *)&clnt_res);
}
