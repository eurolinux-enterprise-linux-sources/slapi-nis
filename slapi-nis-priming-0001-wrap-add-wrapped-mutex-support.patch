From 43ea9a5c6cf7f2022f1e586bb4514564fd7826cb Mon Sep 17 00:00:00 2001
From: Thierry Bordaz <tbordaz@redhat.com>
Date: Tue, 26 Apr 2016 12:44:56 +0300
Subject: [PATCH 1/4] wrap: add wrapped mutex support

---
 src/wrap.c | 90 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 src/wrap.h |  6 +++++
 2 files changed, 96 insertions(+)

diff --git a/src/wrap.c b/src/wrap.c
index c89638f..f8056a4 100644
--- a/src/wrap.c
+++ b/src/wrap.c
@@ -79,6 +79,18 @@ struct wrapped_rwlock {
 #endif
 };
 
+struct wrapped_mutex {
+#if defined(USE_SLAPI_LOCKS)
+	Slapi_Mutex *mutex;
+#elif defined(USE_PTHREAD_LOCKS)
+	pthread_mutex_t mutex;
+#elif defined(USE_NSPR_LOCKS)
+	PRLock *mutex;
+#else
+#error "Unknown thread-safe locking model!"
+#endif
+};
+
 #ifdef USE_NSPR_THREADS
 static void
 wrap_pthread_starter(void *p)
@@ -169,6 +181,84 @@ wrap_thread_stopfd(struct wrapped_thread *t)
 	return ret;
 }
 
+struct wrapped_mutex *
+wrap_new_mutex(void)
+{
+	struct wrapped_mutex *mutex;
+	mutex = malloc(sizeof(*mutex));
+	if (mutex == NULL) {
+		return NULL;
+	}
+#ifdef USE_SLAPI_LOCKS
+	mutex->mutex = slapi_new_mutex();
+	if (mutex->mutex == NULL) {
+		free(mutex);
+		return NULL;
+	}
+#endif
+#ifdef USE_PTHREAD_LOCKS
+	if (pthread_mutex_init(&mutex->mutex, NULL) != 0) {
+		free(mutex);
+		return NULL;
+	}
+#endif
+#ifdef USE_NSPR_LOCKS
+	mutex->mutex = PR_NewLock();
+	if (mutex->mutex == NULL) {
+		free(mutex);
+		return NULL;
+	}
+#endif
+	return mutex;
+}
+
+void
+wrap_free_mutex(struct wrapped_mutex *mutex)
+{
+#ifdef USE_SLAPI_LOCKS
+	slapi_destroy_mutex(mutex->mutex);
+#endif
+#ifdef USE_PTHREAD_LOCKS
+	pthread_mutex_destroy(&mutex->mutex);
+#endif
+#ifdef USE_NSPR_LOCKS
+	PR_DestroyLock(mutex->mutex);
+#endif
+	free(mutex);
+}
+
+int
+wrap_mutex_lock(struct wrapped_mutex *mutex)
+{
+#ifdef USE_SLAPI_LOCKS
+	slapi_lock_mutex(mutex->mutex);
+        return 0;
+#endif
+#ifdef USE_PTHREAD_LOCKS
+	return pthread_mutex_lock(&mutex->mutex);
+#endif
+#ifdef USE_NSPR_LOCKS
+	PR_Lock(mutex->mutex);
+	return 0;
+#endif
+}
+
+int
+wrap_mutex_unlock(struct wrapped_mutex *mutex)
+{
+#ifdef USE_SLAPI_LOCKS
+	return slapi_unlock_mutex(mutex->mutex);
+#endif
+#ifdef USE_PTHREAD_LOCKS
+	return pthread_mutex_unlock(&mutex->mutex);
+#endif
+#ifdef USE_NSPR_LOCKS
+	PR_Unlock(mutex->mutex);
+	return 0;
+#endif
+}
+
+
 struct wrapped_rwlock *
 wrap_new_rwlock(void)
 {
diff --git a/src/wrap.h b/src/wrap.h
index 71bd326..2b797f7 100644
--- a/src/wrap.h
+++ b/src/wrap.h
@@ -23,6 +23,7 @@
 #define wrap_h
 
 struct wrapped_thread;
+struct wrapped_mutex;
 struct wrapped_rwlock;
 
 struct wrapped_thread * wrap_start_thread(void * (*fn)(struct wrapped_thread *),
@@ -31,6 +32,11 @@ void *wrap_stop_thread(struct wrapped_thread *t);
 void *wrap_thread_arg(struct wrapped_thread *t);
 int wrap_thread_stopfd(struct wrapped_thread *t);
 
+struct wrapped_mutex *wrap_new_mutex(void);
+void wrap_free_mutex(struct wrapped_mutex *mutex);
+int wrap_mutex_lock(struct wrapped_mutex *mutex);
+int wrap_mutex_unlock(struct wrapped_mutex *mutex);
+
 struct wrapped_rwlock *wrap_new_rwlock(void);
 void wrap_free_rwlock(struct wrapped_rwlock *rwlock);
 int wrap_rwlock_rdlock(struct wrapped_rwlock *rwlock);
-- 
2.7.4

